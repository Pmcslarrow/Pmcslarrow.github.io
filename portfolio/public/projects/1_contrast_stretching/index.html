<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>High-Performance Image Processing via Parallel Contrast Stretching | ExampleSite</title><meta name=keywords content="c++,mpi,hpc,parallel"><meta name=description content="Built with MPI in C++"><meta name=author content="Me"><link rel=canonical href=http://localhost:1313/projects/1_contrast_stretching/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/projects/1_contrast_stretching/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/projects/1_contrast_stretching/"><meta property="og:site_name" content="ExampleSite"><meta property="og:title" content="High-Performance Image Processing via Parallel Contrast Stretching"><meta property="og:description" content="Built with MPI in C++"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="projects"><meta property="article:published_time" content="2024-05-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-01T00:00:00+00:00"><meta property="article:tag" content="C++"><meta property="article:tag" content="Mpi"><meta property="article:tag" content="Hpc"><meta property="article:tag" content="Parallel"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="High-Performance Image Processing via Parallel Contrast Stretching"><meta name=twitter:description content="Built with MPI in C++"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Projects","item":"http://localhost:1313/projects/"},{"@type":"ListItem","position":2,"name":"High-Performance Image Processing via Parallel Contrast Stretching","item":"http://localhost:1313/projects/1_contrast_stretching/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"High-Performance Image Processing via Parallel Contrast Stretching","name":"High-Performance Image Processing via Parallel Contrast Stretching","description":"Built with MPI in C++","keywords":["c++","mpi","hpc","parallel"],"articleBody":"Overview This project parallelized a sequential contrast stretching algorithm using MPI to create a distributed solution. I achieved approximately a 10× speedup compared to the sequential version. Before arriving at the distributed solution, I also parallelized the algorithm using OpenMP for a shared-memory implementation. However, the more interesting and impactful result was the distributed solution, which also accounted for complexities such as halo rows.\nProblem Statement Contrast stretching is an image enhancement technique that improves the clarity of an image by expanding the range of intensity values.\nTo achieve this, you can think of it as a nearest neighbors problem, where the newly updated pixel value is dependant on the pixels surrounding it.\nPretty simple… The sequential solution to this is as simple as iterating over all the pixels in the matrix (not including the boundaries) and adjusting the pixels.\nThe complexity comes when parallelizing this solution. To achieve this with MPI, we could make it very easy on ourselves and send the entire up-to-date image to each worker, and have them process the portion of the image that they need to process, and then send back the entire updated image, and have the main process stitch it back in.\nThis, however, is extremely inefficient when it comes to memory efficiency. Therefore, the best solution to this problem is to send chunks of rows to each worker, and have each worker process the appropriate rows and send back the processed rows for the main process to gather.\nThis is what this project successfully accomplishes at a high level, but there are three other problems that we must understand in more detail before discussing the implementation.\nProblem 1: Ghost Rows Recall that this is a nearest neighbor algorithm that relies on the pixels around to make the calculation. When we split the image into chunks, each worker (including the main process) is missing the rows surrounding the chunk to be able to make the correct calculations.\nFor example, if we look at worker 1 in the image above (second from the left), to be able to calculate the correct values for the top and bottom rows in the chunk, we actually need the up-to-date rows from the workers around it. This means, for worker 1, it needs the top row from worker 2, and needs the bottom row from worker 0.\nProblem 2: Alignment / Convergence Problem 3: ","wordCount":"397","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-05-01T00:00:00Z","dateModified":"2024-05-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/projects/1_contrast_stretching/"},"publisher":{"@type":"Organization","name":"ExampleSite","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/projects/ title=projects><span>projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/projects/>Projects</a></div><h1 class="post-title entry-hint-parent">High-Performance Image Processing via Parallel Contrast Stretching</h1><div class=post-description>Built with MPI in C++</div></header><div class=post-content><h3 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h3><p>This project parallelized a sequential contrast stretching algorithm using MPI to create a distributed solution. I achieved approximately a 10× speedup compared to the sequential version. Before arriving at the distributed solution, I also parallelized the algorithm using OpenMP for a shared-memory implementation. However, the more interesting and impactful result was the distributed solution, which also accounted for complexities such as halo rows.</p><h3 id=problem-statement>Problem Statement<a hidden class=anchor aria-hidden=true href=#problem-statement>#</a></h3><p>Contrast stretching is an image enhancement technique that improves the clarity of an image by expanding the range of intensity values.</p><p>To achieve this, you can think of it as a nearest neighbors problem, where the newly updated pixel value is dependant on the pixels surrounding it.</p><div><img src=/images/contrast_stretching/contrast.png alt="Scattering an image across workers" width=500px style="display:block;margin:0 auto"></div><p>Pretty simple&mldr; The sequential solution to this is as simple as
iterating over all the pixels in the matrix (not including the boundaries) and adjusting the pixels.</p><p>The complexity comes when parallelizing this solution. To achieve this with MPI, we could make it very easy on ourselves and send the entire up-to-date image to each worker, and have them process the portion of the image that they need to process, and then send back the entire updated image, and have the main process stitch it back in.</p><p>This, however, is extremely inefficient when it comes to memory efficiency. Therefore, the best solution to this problem is to send chunks of rows to each worker, and have each worker process the appropriate rows and send back the processed rows for the main process to gather.</p><div><img src=/images/contrast_stretching/scattering.png alt="Scattering an image across workers" width=500px style="display:block;margin:0 auto"></div><p>This is what this project successfully accomplishes at a high level, but there are three other problems that we must understand in more detail before discussing the implementation.</p><h3 id=problem-1-ghost-rows>Problem 1: Ghost Rows<a hidden class=anchor aria-hidden=true href=#problem-1-ghost-rows>#</a></h3><p>Recall that this is a nearest neighbor algorithm that relies on the pixels around to make the calculation. When we split the image into chunks, each worker (including the main process) is missing the rows surrounding the chunk to be able to make the correct calculations.</p><p>For example, if we look at worker 1 in the image above (second from the left), to be able to calculate the correct values for the top and bottom rows in the chunk, we actually need the up-to-date rows from the workers around it. This means, for worker 1, it needs the top row from worker 2, and needs the bottom row from worker 0.</p><div><img src=/images/contrast_stretching/ghost_rows.png alt="Ghost rows image" width=250px style="display:block;margin:0 auto"></div><h3 id=problem-2-alignment--convergence>Problem 2: Alignment / Convergence<a hidden class=anchor aria-hidden=true href=#problem-2-alignment--convergence>#</a></h3><h3 id=problem-3>Problem 3:<a hidden class=anchor aria-hidden=true href=#problem-3>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/c++/>C++</a></li><li><a href=http://localhost:1313/tags/mpi/>Mpi</a></li><li><a href=http://localhost:1313/tags/hpc/>Hpc</a></li><li><a href=http://localhost:1313/tags/parallel/>Parallel</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>ExampleSite</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>